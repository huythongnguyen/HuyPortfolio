# Algorithm Patterns
## Systematic Interview Preparation

**Purpose:** Master 10 fundamental algorithm patterns through progressive learning. Each pattern builds from beginner to advanced levels with concrete examples and grading criteria.

---

## The Complete Syllabus

This guide contains 10 comprehensive algorithm patterns organized by progressive difficulty. Each lesson includes multiple levels, real interview problems, and detailed grading dimensions.

### Pattern 1: Search / Lookup
**Difficulty:** Beginner | **Time:** 3-4 hours

Find element(s) matching a condition. Master efficient search techniques from O(1) hash table lookups to O(log n) binary search. Learn to recognize when sorted data enables optimization and how to trade space for time.

**Key Signals:** Sorted data, repeated lookups, range queries, monotonic function, search space reduction

**Algorithms:** Binary Search, Hash Table, Binary Search on Answer

---

### Pattern 2: Two Pointers / Sliding Window
**Difficulty:** Beginner | **Time:** 4-5 hours

Find subarray/substring satisfying constraints. Transform O(nÂ²) brute force solutions into elegant O(n) algorithms using two pointers. Master techniques from basic in-place modification to advanced multi-pointer techniques.

**Key Signals:** Contiguous elements, sorted array, window/subarray, palindrome, partitioning

**Algorithms:** Two Pointers, Sliding Window, Fast & Slow Pointers

---

### Pattern 3: Sorting / Ordering
**Difficulty:** Beginner | **Time:** 3-4 hours

Arrange elements by criteria. Understand when sorting unlocks optimization opportunities. Master techniques from basic merging to interval scheduling and custom comparators.

**Key Signals:** Order matters, K-th element, intervals, relative ordering, scheduling

**Algorithms:** Sorting, Merge Sort, Quick Select, Counting Sort, Bucket Sort

---

### Pattern 4: Dynamic Programming
**Difficulty:** Intermediate | **Time:** 6-8 hours

Optimize overlapping subproblems. Transform recursive solutions into efficient bottom-up or memoized approaches. Master the art of state definition and transition.

**Key Signals:** Overlapping subproblems, optimal substructure, counting, optimization

**Algorithms:** DP (1D, 2D, State Machine), Memoization, Tabulation

---

### Pattern 5: Graph Traversal
**Difficulty:** Intermediate | **Time:** 5-6 hours

Explore connected structures. Master BFS for shortest paths and level-order traversal, DFS for connectivity and cycle detection. Learn when to use each approach.

**Key Signals:** Connected components, shortest path, islands, dependencies, cycles

**Algorithms:** BFS, DFS, Topological Sort, Union Find

---

### Pattern 6: Tree Operations
**Difficulty:** Intermediate | **Time:** 5-6 hours

Navigate hierarchical structures. Master recursion on trees, traversal patterns, and tree-specific optimizations. Learn to think recursively about left and right subtrees.

**Key Signals:** Hierarchical data, parent-child relationships, path sum, level order

**Algorithms:** Tree Traversal (Inorder, Preorder, Postorder, Level Order), BST Operations

---

### Pattern 7: Backtracking
**Difficulty:** Advanced | **Time:** 6-8 hours

Explore all possibilities systematically. Build solutions incrementally and prune invalid paths early. Master the generate-and-test paradigm with intelligent search.

**Key Signals:** All combinations/permutations, constraints, decision trees, exhaustive search

**Algorithms:** Backtracking, Constraint Propagation, Pruning

---

### Pattern 8: Greedy
**Difficulty:** Intermediate | **Time:** 4-5 hours

Make locally optimal choices. Learn to prove greedy choice property and optimal substructure. Master interval scheduling, activity selection, and exchange arguments.

**Key Signals:** Optimization, scheduling, selection, exchange argument applies

**Algorithms:** Greedy Choice, Activity Selection, Huffman Coding

---

### Pattern 9: Divide & Conquer
**Difficulty:** Advanced | **Time:** 5-6 hours

Break problems into smaller pieces. Master the divide-conquer-combine paradigm. Learn to analyze recurrence relations and recognize when problems are divisible.

**Key Signals:** Problem divisible into independent subproblems, merge results, recursion

**Algorithms:** Merge Sort, Quick Sort, Binary Search variants, Master Theorem

---

### Pattern 10: Heap / Priority Queue
**Difficulty:** Intermediate | **Time:** 4-5 hours

Maintain partial order efficiently. Master heap operations for k-way merges, top-k problems, and median finding. Learn when O(log n) insert/delete beats sorting.

**Key Signals:** K-th smallest/largest, median, streaming data, merge K lists

**Algorithms:** Min/Max Heap, Priority Queue, Heap Sort

---

## Learning Path Recommendations

### For Beginners
Start with patterns 1-3 in order:
1. Search / Lookup (foundation)
2. Two Pointers (optimization mindset)
3. Sorting (preprocessing strategy)

### For Intermediate
After mastering 1-3, tackle in this order:
4. Dynamic Programming (core interview skill)
5. Graph Traversal (essential data structure)
6. Tree Operations (recursive thinking)

### For Advanced
Complete the journey with:
7. Backtracking (systematic exploration)
8. Greedy (proof-based optimization)
9. Divide & Conquer (algorithmic paradigm)
10. Heap / Priority Queue (advanced data structure)

---

## How to Use This Guide

Each pattern follows a consistent structure:

1. **Overview** - Problem type, difficulty, time estimate
2. **Key Signals** - When to apply this pattern
3. **Progressive Levels** - From foundation to advanced
4. **Grading Dimensions** - What interviewers evaluate
5. **Example Problems** - Real LeetCode questions
6. **Implementation Guide** - Step-by-step walkthroughs

**Study Strategy:**
- Complete patterns in recommended order
- Spend estimated time per pattern
- Master each level before advancing
- Practice problems at each level
- Review grading dimensions before mock interviews

---

**Total Time Commitment:** 48-62 hours for complete mastery
**Recommended Pace:** 2-3 patterns per week
**Completion Target:** 4-6 weeks of consistent study

---

*Crafted with systematic rigor for algorithmic excellence.*
